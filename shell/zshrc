###########################################################
# general customization
###########################################################

if [[ -f ~/.dircolors ]]; then
    eval "export $(dircolors --sh ~/.dircolors)"
fi
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}
autoload -U add-zsh-hook
autoload -Uz compinit && compinit

# regular expressions
autoload -U regexp-replace

# colors
autoload -U colors && colors
setopt prompt_subst

# auto cd
setopt autocd

# case insensitive globbing
# https://stackoverflow.com/questions/156916
setopt extendedglob
unsetopt CASE_GLOB

# case insensitive autocomplete
# https://unix.stackexchange.com/questions/185537
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'
#setopt MENU_COMPLETE # this is to automatically get completion; similar to cmd and powershell

# word splitting - non alphanumeric chars treated as part of a word
# default is '*?_-.[]~=/&;!#$%^(){}<>'
WORDCHARS='*?_-.[]~=&;!#$%^(){}<>'  # remove /

# configure history
export HISTFILE="$HOME/.zsh.history"
export HISTSIZE=1000000
export HISTFILESIZE=
export SAVEHIST=$HISTSIZE
setopt inc_append_history share_history
setopt hist_ignore_all_dups
setopt hist_ignore_space
bindkey '^R' history-incremental-search-backward
bindkey '^T' history-incremental-search-forward

# vim mode!
bindkey -v
bindkey '^H' backward-delete-char
bindkey '^?' backward-delete-char
bindkey '^W' backward-kill-word
bindkey '^U' backward-kill-line

# aliases
alias l='ls --color=tty'
alias ls='ls --color=tty'
alias ll='ls --color=tty -lh'
alias la='ls --color=tty -Ah'
alias lla='ls --color=tty -Alh'
alias cd..='cd ..'
alias tmux='tmux -2'
alias tmux-ssh='tmux -2 -f ~/.tmux.conf.ssh -S /tmp/tmux-ssh'
alias tb='tmux attach-session -t base || tmux new-session -s base'
alias dhcp='dhclient -r && dhclient'
alias cat='cat -v'
alias unset-proxy='unset http_proxy https_proxy HTTP_PROXY HTTPS_PROXY'
alias unset-hist='unset HISTFILE'
alias brm='/bin/rm'
alias less='less -R'
alias gdb='gdb -q'
alias grep='grep --color=always'

if [[ $(uname -a) =~ ".*Cygwin.*" ]]; then
    alias clear='echo -e "\033c"'
    alias psh='echo "\n" | powershell'
fi

# specific host & user settings outside version control
if [[ -f ~/.zshrc.add ]]; then
    source ~/.zshrc.add
fi

# misc
export ZSH_BINARY=$(which zsh)  # needed for .tmux.common
export GPG_TTY=$(tty)           # needed for gpg-agent; see man page

NVIM_BIN=$(which nvim 2> /dev/null)
if [[ $? == 0 ]]; then
    export EDITOR=NVIM_BIN      # use neovim if available
    alias vim='nvim'
else
    export EDITOR=$(which vim)  # otherwise fallback to vim
fi

###########################################################
# functions
###########################################################

# this function permits the command 'lsw $arg' which performs 'ls -l $(which $arg)'
lsw() {
    local w=$(which $1)
    if [[ $w == "$1" ]]; then # if which fails, $w becomes first word in output
        echo "$w not found"
    else
        ls -l $w
    fi
}

# these two functions enable execution of the previous command with sudo in front of it.
save_prev_command() {
    # arguments:
    # $1 line as it was written
    # $2 line with alias expanded and truncated with a certain size limit
    # $3 full line with alias expanded
    if [[ $CURRENT_COMMAND != 'fuck' ]]; then
        PREVIOUS_COMMAND=$CURRENT_COMMAND
    fi
    CURRENT_COMMAND=$2
}
add-zsh-hook preexec save_prev_command

fuck() {
    # try to remove some unwanted characters and
    # hopefully prevent a nasty command injection here
    regexp-replace PREVIOUS_COMMAND '[><;]|(\|\|)|(&&)' ''
    eval "sudo $PREVIOUS_COMMAND"
}

# this function executes the firewall script based on the hostname
fw() {
    if [[ $(id -u) == 0 ]]; then
        eval "/root/firewall-$(hostname).sh $@"
    else
        echo 'Only root can manipulate the firewall...'
    fi
}

# this function shows all 255 color codes
show-colors() {
    for i in {0..255}; do
        echo -e "\e[38;05;${i}m${i}"
    done | column -c 80 -s " "
    echo -e "\e[m"
}

# this function calcultates the size of all directories and files in the cwd
sz() {
    pwd
    du -hs .
    for node in * ; do
        du -hs "$node"
    done
}

# the following two function help me time my stuff
stopwatch() {
    date_start=$(date +%s)
    while true; do
        echo -ne "$(date -u --date @$(( $(date +%s) - $date_start )) +%H:%M:%S)\r"
    done
}

countdown() {
    if [[ $# == 0 ]]; then
        echo "Usage: countdown [seconds] [ minutes [hours] ]"
        return
    elif [[ $# == 1 ]]; then
        local date_start=$(( $(date +%s) + $1 ))
    elif [[ $# == 2 ]]; then
        local date_start=$(( $(date +%s) + $1 + $2 * 60 ))
    elif [[ $# == 3 ]]; then
        local date_start=$(( $(date +%s) + $1 + $2 * 60 + $3 * 60 * 60 ))
    fi

    while [ $date_start -ge `date +%s` ]; do
        echo -ne "$(date -u --date @$(( $date_start - $(date +%s) )) +%H:%M:%S)\r";
    done
}

# special purpose rm which moves files to ~/.trash instead of actually removing them
rm() {
    if [[ ! -d ~/.trash ]]; then
        mkdir ~/.trash
    fi
    for file in "$@"; do
        local base="$(basename $file)"
        if [[ -a ~/.trash/$base ]]; then
            local idx=$(/bin/ls -la ~/.trash | grep $base | wc -l)
            mv $file "$HOME/.trash/$base ($idx)"
        else
            mv $file ~/.trash
        fi
    done
}

# function which cleans the ~/.trash directory used by
# the above rm and removes files older than 30 days
clean-trash() {
    local current_time=$(date +%s)
    for file in ~/.trash/*; do
        local change_time=$(stat -c %Z $file)
        local age=$(( (current_time - change_time) / (60. * 60. * 24) ))
        if [[ $age > 30 ]]; then
            /bin/rm -rf $file
        fi
    done
}

# reload the ~/.zshrc file
reload() {
    if [[ -f ~/.zshrc ]]; then
        echo "Reloading config file."
        source ~/.zshrc
    fi
}

# calculate time based otp codes and put the result in the clipboard
totp() {
    local seed=0
    local rawseed=0
    if [[ $# == 0 ]]; then
        while read -r input; do
            rawseed=$( echo $input | grep 'totp' )
            if [[ ! -z $rawseed ]]; then
                seed=$( echo $rawseed | awk '{ split($0, a, " "); print a[2] }' )
            fi
        done
    else
        seed=$1
    fi

    if [[ ! -z $seed ]]; then
        oathtool --totp -b $seed | xsel -ib
        echo "Done."
    else
        echo "No seed has been provided."
    fi
}

# the code below allows the destruction of root
# shells after a certain amount of time
SHELL_PID=$$
IPC_FILE="/tmp/ipc-watchdog-self-destroy-$SHELL_PID"

watchdog-self-destroy() {
    local TIMER_SELF_DESTROY=2
    while [[ $TIMER_SELF_DESTROY > 0 ]]; do
        sleep 60

        IPC_CONTENT=$(cat $IPC_FILE)
        echo '' > $IPC_FILE
        if [[ $IPC_CONTENT == "kick" ]]; then
            TIMER_SELF_DESTROY=15
        else
            TIMER_SELF_DESTROY=$(($TIMER_SELF_DESTROY-1))
        fi

        if [[ $TIMER_SELF_DESTROY == 1 ]]; then
            print $fg[red]'\n!!! Shell session will be closed in one minute !!!'
        elif [[ $TIMER_SELF_DESTROY == 0 ]]; then
            echo 'exit' > $IPC_FILE
        fi
    done
}

kick-watchdog-self-destroy() {
    echo 'kick' > $IPC_FILE
}

start-watchdog-self-destroy() {
    touch $IPC_FILE
    chmod 600 $IPC_FILE
    kick-watchdog-self-destroy
    watchdog-self-destroy $IPC_FILE&
}

clean-watchdog-self-destroy-files() {
    for f in `ls /tmp/ipc-watchdog-self-destroy-*`; do
        local oldpid=$(echo $f | awk '{ split($0, a, "-"); print a[5] }')
        local pidcmd=$(ps -p $oldpid -o comm=)
        if [[ $pidcmd != 'zsh' ]]; then
            rm $f
        fi
    done
}

if [[ $(id -u) == 0 ]]; then
    echo 'Started self destroy watchdog...'
    start-watchdog-self-destroy
fi

# this function performs a grep with all the right flags and pipes through less
grl () {
    grep -r -n "$@" | less
}

# this function will add "sudo " before the command when pressing alt-s
# if using rxvt, make sure the searchable-scrollback extension is removed
insert_sudo() {
    if [[ $BUFFER != "sudo "* ]]; then
        BUFFER="sudo $BUFFER"
        CURSOR+=5
    fi
}
zle -N insert_sudo_widget insert_sudo
bindkey "^[s" insert_sudo_widget

###########################################################
# gpg-agent-info setup
###########################################################

if [[ -f "$HOME/.gpg-agent-info" ]]; then
    . "$HOME/.gpg-agent-info"
    export GPG_AGENT_INFO
    export SSH_AUTH_SOCK
fi

###########################################################
# the PROMPT variable
###########################################################

COLOR_EXTRA='118'

if [[ $(uname -a) =~ ".*Linux.*" ]]; then
    if [[ $(id -u) == 0 ]]; then
        COLOR_USER='51'
    else
        COLOR_USER='196'
    fi

    COLOR_HOST='255' # this is the default

    if [[ $(hostname) =~ 'hthvm\-.*' ]]; then
        COLOR_HOST=208
    elif [[ $(hostname) =~ 'panvm\-.*' ]]; then
        COLOR_HOST=27
    else
        typeset -A HOST_COLORS
        HOST_COLORS=(
            bendis          156
            heretic         156
            gebeleizis      227 # to be removed
            hathor          227
            pan              51
            apozeu           36
            homero           21
            tanya           134
            brainiac         58
        )

        for key in "${(@k)HOST_COLORS}"; do
            if [[ $(hostname) == $key ]]; then
                COLOR_HOST=$HOST_COLORS[$key]
            fi
        done
    fi

    export PROMPT="%F{255}[ %* ]%F{ $COLOR_USER } %n %F{ $COLOR_EXTRA } @ %F{ $COLOR_HOST } %m %F{ $COLOR_EXTRA }: %~ %f "

elif [[ $(uname -a) =~ ".*Cygwin.*" ]]; then
    if [[ $(id -Gn) =~ '.*Administrators.*' ]]; then
        COLOR_USER='51'
    else
        COLOR_USER='196'
    fi

    COLOR_HOST='118'

    export PROMPT="%F{255}[ %* ]%F{ $COLOR_USER } %n%F{ $COLOR_EXTRA }: %~ %f "
fi

export TMUX_COLOR='colour'$COLOR_HOST

# this is needed to show the mode (e.g. normal, insert) when using vimode
# https://superuser.com/questions/151803
# http://pawelgoscicki.com/archives/2012/09/vi-mode-indicator-in-zsh-prompt/
VIM_INS_MODE="[INS]"
VIM_NRM_MODE="[NRM]"
VIM_MODE=$VIM_INS_MODE

function zle-keymap-select {
    VIM_MODE="${${KEYMAP/vicmd/${VIM_NRM_MODE}}/(main|viins)/${VIM_INS_MODE}}"
    zle reset-prompt
}
zle -N zle-keymap-select

function zle-line-finish {
    VIM_MODE=$VIM_INS_MODE
}
zle -N zle-line-finish

# for some reason i currently fail to understand, the line below needs to be exactly as is
# do not change the
RPROMPT='${VIM_MODE}'

# this line makes sure the RPROMPT of previous lines is removed
# https://stackoverflow.com/questions/14316463
setopt transientrprompt

# timeouts to do things every
TMOUT=1 # one second
TRAPALRM() {
    # this is needed to update the time in the prompt every second
    # https://stackoverflow.com/questions/2187829
    zle reset-prompt

    # this is needed to exit from root shells when the watchdog times out
    if [[ $(id -u) == 0 ]]; then
        local IPC_CONTENT=$(cat $IPC_FILE)
        if [[ $IPC_CONTENT == 'exit' ]]; then
            exit
        fi
    fi
}
