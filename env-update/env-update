#! env python3

import argparse
import base64
import configparser
import getpass
import json
import os
import requests
import shutil
import stat

from os.path import expanduser
from colored import fg, attr


def parse_args():
    """parse_args parses the supported command line arguments."""
    parser = argparse.ArgumentParser(description='Update environment configuration files.')
    parser.add_argument(
        '-c', '--config', type=str, default='/etc/env-update.cfg', help='configuration file for this update utility')
    parser.add_argument('-l', '--list', nargs='*', help='show all configuration sections supported for update')
    parser.add_argument('-u', '--update', nargs='*', help='configuration files to be updated')
    args = parser.parse_args()
    return args


def parse_config(f):
    """parse_config loads the configuration file for the script."""
    cfg = configparser.ConfigParser()
    # next line is needed in order to make option names case-sensitive
    # https://stackoverflow.com/questions/1611799
    cfg.optionxform = str
    with open(f, 'r') as fp:
        cfg.read_file(fp)
    return cfg


class Updater:
    """Updater implements the functionality to perform updates of dot files."""

    def __init__(self, cfg, private_token):
        self._cfg = cfg
        self._private_token = private_token

    def do_list(self, sections):
        """do_list prints contents of the configuration file based on the -l/--list argument."""
        if len(sections) == 0:
            self._list_all_sections()
        else:
            for section in sections:
                self._list_section(section)

    def _get_csv(self, section, option):
        """_get_csv loads an option with comma separated values from the specified section."""
        ret = list()
        for i in self._cfg.get(section, option).split(','):
            if len(i) > 0:
                ret.append(i.strip())
        return ret

    def do_update(self, sections):
        """do_update updates dot files based on the -u/--update argument."""
        if sections is None or len(sections) == 0:
            sections = self._get_csv('config', 'default-sections')
        for section in sections:
            self._update_section(section)

    def _parse_config_value(self, value):
        """_parse_config_value splits a configuration value into tokens."""
        tokens = value.split(';')

        path = tokens[0]

        if len(tokens) == 1:
            file_chmod = self._cfg.get('config', 'file_chmod')
            dir_chmod = int(self._cfg.get('config', 'dir_chmod'), 8)
        else:
            file_chmod = tokens[1]

        if len(tokens) == 3:
            dir_chmod = tokens[2]
        else:
            dir_chmod = int(self._cfg.get('config', 'dir_chmod'), 8)

        return path, dir_chmod, file_chmod

    def _color_text(self, color, text):
        """_color_text uses the colored library to set the terminal color for the specified text."""
        return '{}{}{}'.format(fg(color), text, attr('reset'))

    def _list_all_sections(self):
        """_list_all_sections prints all the sections from the configuration file."""
        for section in self._cfg.sections():
            if section == 'config':
                continue

            colored_section = self._color_text('blue', section)
            print('{:<30}'.format(colored_section), end='')

            if self._cfg.has_option(section, 'desc'):
                desc = self._cfg.get(section, 'desc')
                colored_desc = self._color_text('cyan', desc)
                print(colored_desc, end='')

            print()

    def _list_section(self, section):
        """_list_section prints the content of one section from the configuration file, except for the config
        section."""
        if section == 'config':
            return

        if section not in self._cfg.sections():
            print(self._color_text('red', 'section {} does not exist'.format(section)))
            return

        print(self._color_text('blue', section))
        for option in self._cfg.options(section):
            if option == 'desc':
                continue

            value = self._cfg.get(section, option)
            path, _, _, = self._parse_config_value(value)
            colored_path = self._color_text('green', path)
            colored_option = self._color_text('cyan', option)

            print('    {:<40}{}'.format(colored_option, colored_path))

    def _print_update_status(self, is_ok, value):
        """_print_update_status displays the status of a file download operation."""
        path, _, _ = self._parse_config_value(value)
        colored_path = self._color_text('cyan', path)

        status, status_color = ('[✔]', 'green') if is_ok else ('[✘]', 'red')
        colored_status = self._color_text(status_color, status)

        print('  {}  {}'.format(colored_status, colored_path))

    def _clear_directories(self, dirs):
        """_clear_directories removes the content of every directory in the list given as argument."""
        for d in dirs:
            try:
                shutil.rmtree(expanduser(d))
            except FileNotFoundError:
                pass

    def _update_section(self, section):
        """_update_section updates all the files for the specified section in the configuration file."""
        if section == 'config':
            return

        if section not in self._cfg.sections():
            print(self._color_text('red', 'section {} does not exist'.format(section)))
            return
        else:
            print(self._color_text('blue', 'updating {}'.format(section)))

        for option in self._cfg.options(section):
            if option == 'desc':
                continue
            elif option == 'clear':
                dirs = self._get_csv(section, 'clear')
                self._clear_directories(dirs)
            else:
                self._update_file(section, option)

    def _update_file(self, section, option):
        """_update_file updates the specified file from the specified section."""
        value = self._cfg.get(section, option)
        content, is_ok = self._download_file(section, option)

        if is_ok:
            is_ok = self._write_file(value, content)

        self._print_update_status(is_ok, value)

    def _download_file(self, section, option):
        """_download_file attempts to download a file via the gitlab api, using the private token stored in
        /etc/env-update-token.txt."""
        repo_id = 13755372 # taken from the webpage
        file_path = '{}/{}'.format(section, option)

        # basic url encoding
        for c in ['/', '.']:
            file_path = file_path.replace(c, '%' + hex(ord(c)).strip('0x'))

        url = 'https://gitlab.com/api/v4/projects/{repo_id}/repository/files/{file_path}'.format(
            repo_id=repo_id,
            file_path=file_path
        )

        try:
            response = requests.get(url, params={'ref': 'master', 'private_token': self._private_token})
            if response.status_code == 200:
                response_json = json.loads(response.text)
                return base64.b64decode(response_json['content']).decode('utf-8'), True
        except IOError:
            pass

        return None, False

    def _write_file(self, value, content):
        """_write_file creates or updates a file with the specified content. It also sets the file mode bits, and the
        owner to root if the process is running as root."""
        path, dir_chmod, file_chmod = self._parse_config_value(value)
        full_path = expanduser(path)

        try:
            os.makedirs(os.path.dirname(full_path), mode=dir_chmod)
            os.chmod(os.path.dirname(full_path), 0o700)
        except OSError:
            pass

        try:
            with open(full_path, 'w') as fp:
                fp.write(content)
        except PermissionError:
            return False

        os.chmod(full_path, int(file_chmod, 8))
        if os.geteuid() == 0:
            os.chown(full_path, 0, 0)

        return True


def main():
    args = parse_args()
    cfg = parse_config(args.config)
    private_token = getpass.getpass('Gitlab Token: ')
    updater = Updater(cfg, private_token)

    if args.list is not None:
        updater.do_list(args.list)

    updater.do_update(args.update)


if __name__ == '__main__':
    main()
